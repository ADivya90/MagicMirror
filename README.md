# MagicMirror
MagicMirror is an Android App that uses PSGAN's core technology to apply makeup to photos provided by users.


## 1. Overview

There exists a wide variety of beauty tutorials and cosmetic advertisements on the Internet, which does provide consumers with much information, but also leaves them with more questions: which makeup is more suitable for them, whether their skin tone is not good enough to affect the effect of this makeup, etc. The trial makeup magic mirror can generate a photo after makeup based on the sample image based on a vegan picture. Users can judge whether a certain kind of makeup is suitable for them according to the photos generated by the algorithm. Compared with the current beauty software, our users can choose any beauty makeup they want to imitate. The makeup style of the sample picture is not restricted, and the generated makeup photos look realistic.  

![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/1.png)  

## 2. My Work

### 2.1 Designing the main functions of the application
### 2.2.1  Demands
We want to provide a platform for users to experience and share different makeup application effects. Users can apply makeup to pictures. Users can share their makeup pictures with other users.  

#### 2.2.2 Functions     
The main functions of the program are login and registration function, sample list, makeup upload interface, personal information, and upload sample. Users register a new account with their cell phone number and login, as shown in Figure 2. Users can see all the beauty pictures uploaded by other users in the sample list, as shown in Figure 3. Users can apply makeup in the makeup application screen, which supports adjusting the makeup intensity and partial makeup application, as shown in Figure 3. Users can view the sample collection and makeup history on the personal information page, and can upload samples, as shown in Figure 4. Users can change user settings on the personal information page, as shown in Figure 4.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/2.png)  

![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/3.png)  

![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/4.png)  

### 3. Development
In order to improve the readability of the code and the overall robustness of the project, I divided the project into 5 modules as shown in Figure 5.

![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/5.png)

```
1) Annotations Module
Name：annotations，Type：Java Library；
自定义的注解。
```
```
2) Generator Module
Name：compiler，Type：Java Library；
根据自定义的注解生成相应的代码。
```
```
3) Core Module
Name：core，Type：Android Library；
App最核心的、通用的功能。
```
```
4) Business Module
Name：ec，Type： Android Library；
App上妆业务的特有功能。
```
```
5) Function Module
Name：app，Type：Android Application；
调用上妆业务，完成相关处理。
```
#### After completing the project architecture design and module decomposition, I started building the project base framework. This included developing a global configurator and integrating a font icon library.

When designing the global configurator (class Configurator), I followed the "lazy man pattern" under the "singleton pattern" to ensure that the global configuration is consistent and does not take up too much space to maintain consistency. I achieve this using private constructors and private inner classes under Java, as shown in Figure 6.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/6.1.png)  

When designing the global configurator (class Configurator), I followed the "lazy man pattern" under the "singleton pattern" to ensure that the global configuration is consistent and does not take up too much space to maintain consistency. I integrated android-iconify, which can use Font Awesome as the icon source. The font icon and text can be in the same text box, as shown in Figure 7.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/6.png)  

After completing the basic framework of the project, I designed and developed the interface architecture of the app. I designed a common UI framework with single Activity and multiple Fragment, and the interface switching is very smooth. For this purpose, I designed 6 abstract classes as parents of all pages, which are ProxyActivity (parent of all Activities), BaseDelegate (parent of all pages), BaseBottomDelegate (parent of home page with bottom navigation bar), BottomItemDelegate (parent of pages driven by buttons on bottom navigation bar), and BottomItemDelegate (parent of pages driven by buttons on bottom navigation bar). (parent of pages driven by buttons on the bottom navigation bar), PermissionCheckerDelegate (parent of dynamic permission request pages, for Android 6.0+), QiluDelegate (parent of regular pages). These abstract classes contain some generic functions such as dynamic permission request, loading animation, bottom navigation menu bar, as shown in Figure 8.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/7.png)  

In order to improve the efficiency of subsequent development, I designed and developed an efficient and easy-to-use web request framework. Developers can easily use this framework to send and process RESTful requests. The framework itself automatically handles issues related to multithreading and asynchrony. For example, developers can use this framework to upload one or more files, as shown in Figure 9.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/8.png)  


This web request framework is built on Retrofit2. The framework design follows the "builder pattern", which separates the construction of a complex object from its representation, allowing the same construction process to create different representations. Framework for developers to provide a simple and efficient function call interface , with a fairly complete callback (Interface) . The project structure of the framework itself and the callback interface is shown in Figure 10, under the callback package are all the callbacks.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/9.png)  

The core function of the App is to apply makeup to photos, so I designed a fully functional, efficient and reliable image processing interface with image crop, rotation and compression functions, as shown in Figure 11.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/10.png)  

Before the user takes a photo, the app makes a dynamic permission request (for Android 6.0+), as shown in Figure 12.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/11.png)  

The App supports taking photos immediately or selecting photos from the local area, as shown in Figure 13.
![image](https://github.com/Super262/MagicMirror/blob/master/screenshots/12.png)  
